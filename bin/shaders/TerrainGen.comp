#version 460 core
precision highp float;

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D heightMap;

uniform vec3 worldPos;
uniform float chunkSize;
uniform int heightMapRes;

float random(vec3 x) {
	return fract(sin(x.x + x.y * 57.0 + x.z * 113.0) * 43758.5453);
}

float interpolate(float a, float b, float c, float d, float x) {
	float p = (d - c) - (a - b);

	return x * (x * (x * p + ((a - b) - p)) + (c - a)) + b;
}

float sampleX(vec3 at) {
	float floored = floor(at.x);

	return interpolate(random(vec3(floored - 1.0, at.yz)), random(vec3(floored, at.yz)), random(vec3(floored + 1.0, at.yz)), random(vec3(floored + 2.0, at.yz)), fract(at.x)) * 0.5 + 0.25;
}

float sampleY(vec3 at) {
	float floored = floor(at.y);

	return interpolate(sampleX(vec3(at.x, floored - 1.0, at.z)), sampleX(vec3(at.x, floored, at.z)), sampleX(vec3(at.x, floored + 1.0, at.z)), sampleX(vec3(at.x, floored + 2.0, at.z)), fract(at.y));
}

float cubicNoise(vec3 at) {
	float floored = floor(at.z);

	return interpolate(sampleY(vec3(at.xy, floored - 1.0)), sampleY(vec3(at.xy, floored)), sampleY(vec3(at.xy, floored + 1.0)), sampleY(vec3(at.xy, floored + 2.0)), fract(at.z));
}
vec3 permute(vec3 x) {
	return mod(((x * 34.0) + 1.0) * x, 289.0);
}
float snoise(vec2 v) {
	const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
	vec2 i = floor(v + dot(v, C.yy));
	vec2 x0 = v - i + dot(i, C.xx);
	vec2 i1;
	i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
	vec4 x12 = x0.xyxy + C.xxzz;
	x12.xy -= i1;
	i = mod(i, 289.0);
	vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
	vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
	m = m * m;
	m = m * m;
	vec3 x = 2.0 * fract(p * C.www) - 1.0;
	vec3 h = abs(x) - 0.5;
	vec3 ox = floor(x + 0.5);
	vec3 a0 = x - ox;
	m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);
	vec3 g;
	g.x = a0.x * x0.x + h.x * x0.y;
	g.yz = a0.yz * x12.xz + h.yz * x12.yw;
	float val = 130.0 * dot(m, g);
	return (val + 1.0) / 2.0;
}

float ridgenoise(vec2 v) {
	return 2 * (0.5 - abs(0.5 - snoise(v)));
}

float octaveRidgeNoise(vec2 v, int octaves, float freq, float gain) {
	float value = 0.0;
	float amplitude = 1.0;
	float frequency = freq;
	float maxVal = 0.0;

	vec2 grad = vec2(0.0, 0.0);

	for(int i = 0; i < octaves; i++) {
		float noise = ridgenoise(v * frequency);

		value += noise * amplitude;

		maxVal += amplitude;
		amplitude *= gain;
		frequency *= 2.0;
	}

	return value / maxVal;
}

float octaveNoise(vec2 v, int octaves, float freq, float gain) {
	float value = 0.0;
	float amplitude = 1.0;
	float frequency = freq;
	float maxVal = 0.0;

	vec2 grad = vec2(0.0, 0.0);

	for(int i = 0; i < octaves; i++) {
		// vec3 noise = cubicNoise(vec3(v, 0.0) * frequency);
		float noise = snoise(v * frequency);

		// grad += noise.yz * amplitude;
		// float m = length(grad);
		// float k = 0.3;
		value += noise.x * amplitude;

		maxVal += amplitude;
		amplitude *= gain;
		frequency *= 2.0;
	}
	return value / maxVal;
}

float heightFunc(vec2 v) {
	float altitude = octaveNoise(v, 6, 0.0002, 0.3).x;
	altitude = pow(altitude, 1) * 4;

	float plainHeight = altitude + octaveNoise(v, 6, 0.0002, 0.5) + octaveNoise(v, 6, 0.0005, 0.5) * 1;
	float hillHeight = altitude + octaveNoise(v, 10, 0.001, 0.3) * 1.5;
	float mountainHeight = altitude + octaveNoise(v, 5, 0.002, 0.3) * 2 + octaveNoise(v, 10, 0.01, 0.5) * 0.1 + octaveRidgeNoise(v, 4, 0.005, 0.5) * 0.1;

	float y = 0;
	if(altitude < 0.5) {
		float t = smoothstep(0.0, 0.5, altitude);
		y = mix(0.0, plainHeight, t);
	} else if(altitude < 2.0) {
        // Interpolate between plains and hills
		float t = smoothstep(1.0, 2.0, altitude);
		y = mix(plainHeight, hillHeight, t);
	} else if(altitude < 3.0) {
        // Interpolate between hills and mountains
		float t = smoothstep(2.0, 3.0, altitude);
		y = mix(hillHeight, mountainHeight, t);
	} else {
		y = mountainHeight;
	}
	return y * 256;
}

void main() {
	ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	vec2 pixelWorldPos = vec2(pixel) / (heightMapRes - 1) * chunkSize + worldPos.xz - chunkSize / 2.0;

	float height = heightFunc(pixelWorldPos);
	// float height = sin(pixelWorldPos.x / 10 + pixelWorldPos.y / 10) + cos(pixelWorldPos.x / 10 - pixelWorldPos.y / 10);
	// height *= 10;

	vec3 normal = vec3(0.0, 1.0, 0.0);

	if(pixel.x == 0 || pixel.y == 0 || pixel.x == heightMapRes - 1 || pixel.y == heightMapRes - 1) {
		float eps = chunkSize / float(heightMapRes);

		float fx0 = heightFunc(pixelWorldPos + vec2(-eps, 0));
		float fx1 = heightFunc(pixelWorldPos + vec2(eps, 0));
		float fy0 = heightFunc(pixelWorldPos + vec2(0, -eps));
		float fy1 = heightFunc(pixelWorldPos + vec2(0, eps));

		normal = vec3((fx0 - fx1) / (2 * eps), 1, (fy0 - fy1) / (2 * eps));
		normal *= (1.0 / normal.y);
	}

	imageStore(heightMap, pixel, vec4(height, normal.x, normal.z, 0.0));
}