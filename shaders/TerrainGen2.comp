#version 460 core

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(r32f, binding = 0) uniform image2D heightMap;

uniform vec3 worldPos;
uniform int heightMapRes;

// 0: integer hash
// 1: float hash (aliasing based)
#define METHOD 1

// 0: cubic
// 1: quintic
#define INTERPOLANT 0

#if METHOD==0
float hash(ivec3 p)    // this hash is not production ready, please
{                        // replace this by something better

    // 3D -> 1D
	int n = p.x * 3 + p.y * 113 + p.z * 311;

    // 1D hash by Hugo Elias
	n = (n << 13) ^ n;
	n = n * (n * n * 15731 + 789221) + 1376312589;
	return -1.0 + 2.0 * float(n & 0x0fffffff) / float(0x0fffffff);
}
#else
float hash(vec3 p)  // replace this by something better
{
	p = 50.0 * fract(p * 0.3183099 + vec3(0.71, 0.113, 0.419));
	return -1.0 + 2.0 * fract(p.x * p.y * p.z * (p.x + p.y + p.z));
}
#endif

// return value noise (in x) and its derivatives (in yzw)
vec4 noised(in vec3 x) {
    #if METHOD==0
	ivec3 i = ivec3(floor(x));
    #else
	vec3 i = floor(x);
    #endif
	vec3 w = fract(x);

    #if INTERPOLANT==1
    // quintic interpolation
	vec3 u = w * w * w * (w * (w * 6.0 - 15.0) + 10.0);
	vec3 du = 30.0 * w * w * (w * (w - 2.0) + 1.0);
    #else
    // cubic interpolation
	vec3 u = w * w * (3.0 - 2.0 * w);
	vec3 du = 6.0 * w * (1.0 - w);
    #endif    

    #if METHOD==0
	float a = hash(i + ivec3(0, 0, 0));
	float b = hash(i + ivec3(1, 0, 0));
	float c = hash(i + ivec3(0, 1, 0));
	float d = hash(i + ivec3(1, 1, 0));
	float e = hash(i + ivec3(0, 0, 1));
	float f = hash(i + ivec3(1, 0, 1));
	float g = hash(i + ivec3(0, 1, 1));
	float h = hash(i + ivec3(1, 1, 1));
	#else
	float a = hash(i + vec3(0, 0, 0));
	float b = hash(i + vec3(1, 0, 0));
	float c = hash(i + vec3(0, 1, 0));
	float d = hash(i + vec3(1, 1, 0));
	float e = hash(i + vec3(0, 0, 1));
	float f = hash(i + vec3(1, 0, 1));
	float g = hash(i + vec3(0, 1, 1));
	float h = hash(i + vec3(1, 1, 1));
    #endif

	float k0 = a;
	float k1 = b - a;
	float k2 = c - a;
	float k3 = e - a;
	float k4 = a - b - c + d;
	float k5 = a - c - e + g;
	float k6 = a - b - e + f;
	float k7 = -a + b + c - d + e - f - g + h;

	return vec4(k0 + k1 * u.x + k2 * u.y + k3 * u.z + k4 * u.x * u.y + k5 * u.y * u.z + k6 * u.z * u.x + k7 * u.x * u.y * u.z, du * vec3(k1 + k4 * u.y + k6 * u.z + k7 * u.y * u.z, k2 + k5 * u.z + k4 * u.x + k7 * u.z * u.x, k3 + k6 * u.x + k5 * u.y + k7 * u.x * u.y));
}
// vec3 permute(vec3 x) {
// 	return mod(((x * 34.0) + 1.0) * x, 289.0);
// }

float snoise(vec2 v) {
	const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
	vec2 i = floor(v + dot(v, C.yy));
	vec2 x0 = v - i + dot(i, C.xx);
	vec2 i1;
	i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
	vec4 x12 = x0.xyxy + C.xxzz;
	x12.xy -= i1;
	i = mod(i, 289.0);
	vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
	vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
	m = m * m;
	m = m * m;
	vec3 x = 2.0 * fract(p * C.www) - 1.0;
	vec3 h = abs(x) - 0.5;
	vec3 ox = floor(x + 0.5);
	vec3 a0 = x - ox;
	m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);
	vec3 g;
	g.x = a0.x * x0.x + h.x * x0.y;
	g.yz = a0.yz * x12.xz + h.yz * x12.yw;
	float val = 130.0 * dot(m, g);
	return (val + 1.0) / 2.0;
}

// float ridgenoise(vec2 v) {
// 	return 2 * (0.5 - abs(0.5 - snoise(v)));
// }

vec3 octaveNoise(vec2 v, int octaves, float freq, float gain) {
	float value = 0.0;
	float amplitude = 1.0;
	float frequency = freq;
	float maxVal = 0.0;

	vec2 grad = vec2(0.0, 0.0);

	for(int i = 0; i < octaves; i++) {
		vec3 noise = noised(vec3(v, 0.0) * frequency).xyz;

		grad += noise.yz * amplitude;
		float m = length(grad);
		float k = 0.3;
		value += (noise.x + 1) / 2 * amplitude / (1 + k * m);

		maxVal += amplitude;
		amplitude *= gain;
		frequency *= 2.0;
	}

	return vec3(value / maxVal, grad);
}

float heightFunc(vec2 v) {
	vec3 lowFreq = octaveNoise(v, 4, 0.001, 0.35) * 4;
	float lowFreqHeight = lowFreq.x;
	vec2 grad = lowFreq.yz;

	vec3 highFreq = octaveNoise(v, 10, 0.02, 0.5) * 0.1;
	grad += highFreq.yz;
	float highFreqHeight = highFreq.x / (1 + 0.5 * length(grad));

// 	highFreq = pow(highFreq, 1.4) * 0.05;

// 	lowFreq = pow(lowFreq, 2) * 4;

// 	float highhighFreq = octaveNoise(v, 6, 2, 0.5) * 0.005;

	// float y = lowFreq + highFreq + highhighFreq;
	// float y = octaveNoise(v, 20, 0.003, 0.5);
	float y = lowFreqHeight + highFreqHeight;

	// float y = noised(vec3(v / 200.0, 0.0)).x;
	return y * 256;
}

void main() {
	ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	vec2 pixelWorldPos = vec2(pixel) / heightMapRes * 256 + worldPos.xz;

	float height = heightFunc(pixelWorldPos * 2);

	imageStore(heightMap, pixel, vec4(height, 0.0, 0.0, 0.0));
}